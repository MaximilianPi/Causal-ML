grads =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
# tmp[,1] = (df[i,-1,drop=FALSE])[,2]
tmp[,1] = tmp[,1]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,1]-df[i-1, 2]))
})
mean(grads)
eps = 0.1*sd(dat2[,3])
df = dat2[order(dat2[,3], decreasing=FALSE), ]
grads2 =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
#tmp[,2] = (df[i,-1,drop=FALSE])[,3]
tmp[,2] = tmp[,2]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,2]-df[i-1, 3]))
})
mean(grads2)
dat2 = scale(dat2)
brt = xgboost::xgboost(data=xgboost::xgb.DMatrix(dat2[,-1], label = (dat2[,1, drop=FALSE])),
nrounds = 200L, objective="reg:linear",params = list(nthread = 3))
mm = (lm(y~., data = dat))
margins::margins(mm)
dat = scale(dat)
mm = (lm(y~., data = dat))
mm = (lm(y~., data = as.data.frame(dat)))
margins::margins(mm)
coef(mm)
df = dat2[order(dat2[,2], decreasing=FALSE), ]
eps = 0.1*sd(dat2[,2])
grads =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
# tmp[,1] = (df[i,-1,drop=FALSE])[,2]
tmp[,1] = tmp[,1]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,1]-df[i-1, 2]))
})
mean(grads)
eps = 0.1*sd(dat2[,3])
df = dat2[order(dat2[,3], decreasing=FALSE), ]
grads2 =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
#tmp[,2] = (df[i,-1,drop=FALSE])[,3]
tmp[,2] = tmp[,2]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,2]-df[i-1, 3]))
})
mean(grads2)
coef(mm)
rr = (get_importance2(brt, predict_xg, dat))
rr[[2]]
df2 = rr[[1]]$results$x1[,2:3]
model = gam(.value~.borders, data = df2)
y1 = predict(model, newdata= data.frame(.borders= df2$.borders))
y2 = predict(model, newdata= data.frame(.borders= df2$.borders+0.01))
mean((y2-y1)/(df2$.borders+0.01 - df2$.borders))
df2 = rr[[1]]$results$x2[,2:3]
model = gam(.value~.borders, data = df2)
y1 = predict(model, newdata= data.frame(.borders= df2$.borders))
y2 = predict(model, newdata= data.frame(.borders= df2$.borders+0.01))
mean((y2-y1)/(df2$.borders+0.01 - df2$.borders))
coef(mm)
df2 = rr[[1]]$results$x2[,2:3]
mean((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x1[,2:3]
mean((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
mean(grads)
mean(grads2)
df = dat2[order(dat2[,2], decreasing=FALSE), ]
eps = 0.01*sd(dat2[,2])
grads =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
# tmp[,1] = (df[i,-1,drop=FALSE])[,2]
tmp[,1] = tmp[,1]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,1]-df[i-1, 2]))
})
mean(grads)
eps = 0.01*sd(dat2[,3])
df = dat2[order(dat2[,3], decreasing=FALSE), ]
grads2 =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
#tmp[,2] = (df[i,-1,drop=FALSE])[,3]
tmp[,2] = tmp[,2]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,2]-df[i-1, 3]))
})
mean(grads2)
mean((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
mean((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x2[,2:3]
grads_ALE = ((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x2[,2:3]
grads_ALE = ((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x1[,2:3]
grads_ALE = ((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x2[,2:3]
grads_ALE1 = ((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
df2 = rr[[1]]$results$x1[,2:3]
grads_ALE2 = ((df2$.value[2:21]-df2$.value[1:20])/(df2$.borders[2:21] - df2$.borders[1:20]))
mean(abs(grads_ALE1)
)
mean(abs(grads_ALE2))
y = x1**2 + x2 + 0*x3 + rnorm(n)
plot(x1, y)
dat = data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5, x6 = x6)
nn = data.frame(matrix(runif(n*20), n, 20))
colnames(nn) = paste0("A", 1:20)
dat = cbind(dat, nn)
cor(dat$x1, dat$x2)
summary(lm(y~., data = dat))
dat2 = as.matrix(dat)
dat2 = scale(dat2)
brt = xgboost::xgboost(data=xgboost::xgb.DMatrix(dat2[,-1], label = (dat2[,1, drop=FALSE])),
nrounds = 200L, objective="reg:linear",params = list(nthread = 3))
dat = scale(dat)
rr = (get_importance2(brt, predict_xg, dat))
df = dat2[order(dat2[,2], decreasing=FALSE), ]
eps = 0.1*sd(dat2[,2])
grads =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
# tmp[,1] = (df[i,-1,drop=FALSE])[,2]
tmp[,1] = tmp[,1]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,1]-df[i-1, 2]))
})
mean(grads)
eps = 0.1*sd(dat2[,3])
df = dat2[order(dat2[,3], decreasing=FALSE), ]
grads2 =
sapply(2:1000, function(i) {
y1 = predict_xg(brt, newdata= (df[i-1,-1,drop=FALSE]))
tmp = (df[i-1,-1,drop=FALSE])
#tmp[,2] = (df[i,-1,drop=FALSE])[,3]
tmp[,2] = tmp[,2]+eps
y2 = predict_xg(brt, newdata= tmp)
return((y2-y1)/(tmp[,2]-df[i-1, 3]))
})
mean(grads2)
summary(mm)
mm = (lm(y~., data = as.data.frame(dat)))
summary(mm)
grads
mean(grads)
mean(grads2)
mean(abs(grads))
mean(abs(grads2))
sd(grads)
sd(grads2)
AME_direct = function(data, predict_f, model) {
res=
sapply(1:ncol(data), function(p) {
eps = 0.1*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(res)
}
AME_direct(dat2, predict_xg, brt)
AME_direct(dat, predict_xg, brt)
data = dat2
predict_f = predict_xg
model = brt
p = 1
eps = 0.1*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
i =1
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp1
AME_direct(dat2[,-1], predict_xg, brt)
res_AME_direct = AME_direct(dat2[,-1], predict_xg, brt)
t(res_AME_direct)
t(res_AME_direct)[,1]
AME_direct = function(data, predict_f, model, epsilon = 0.1) {
res=
sapply(1:ncol(data), function(p) {
eps = epsilon*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(res)
}
res_AME_direct = AME_direct(dat2[,-1], predict_xg, brt, 0.001)
t(res_AME_direct)
res_AME_direct = AME_direct(dat2[,-1], predict_xg, brt, 1.1)
t(res_AME_direct)
res_AME_direct = AME_direct(dat2[,-1], predict_xg, brt)
plot(res_AME_direct)
t(res_AME_direct)
res
rr
ALE = rr[[1]]
ALE$results
results = ALE$results
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
feature = results$x1
len = length(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
grads
results$x1
((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
len
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
grads
AME_ALE = function(data, predict_f, model) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(res)
}
res_AME_ALE = AME_ALE(dat2[,-1], predict_xg, brt)
AME_direct = function(data, predict_f, model, epsilon = 0.1) {
data = data[,-1]
res=
sapply(1:ncol(data), function(p) {
eps = epsilon*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(res)
}
res_AME_direct = AME_direct(dat2[,-1], predict_xg, brt)
res_AME_direct = AME_direct(dat2, predict_xg, brt)
res_AME_direct
AME_ALE = function(data, predict_f, model) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(res)
}
res_AME_ALE = AME_ALE(dat2, predict_xg, brt)
res_AME_ALE
t(res_AME_ALE)
AME_ALE = function(data, predict_f, model, epsilon = NULL) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
if(!is.null(epsilon)){
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
} else {
res=
sapply(results, function(feature) {
model = gam(.value~.borders, data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = mean((y2-y1)/(feature$.borders+epsilon - feature$.borders))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
}
return(res)
}
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt))
AME_ALE = function(data, predict_f, model, epsilon = NULL) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
if(is.null(epsilon)){
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
} else {
res=
sapply(results, function(feature) {
model = gam(.value~.borders, data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = mean((y2-y1)/(feature$.borders+epsilon - feature$.borders))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
}
return(res)
}
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt))
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.01))
feature
model = gam(.value~.borders, data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
y1
y2
grads = mean((y2-y1)/(feature$.borders+epsilon - feature$.borders))
epsilon
epsilon = 0.01
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = mean((y2-y1)/(feature$.borders+epsilon - feature$.borders))
grads
AME_ALE = function(data, predict_f, model, epsilon = NULL) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
if(is.null(epsilon)){
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
} else {
res=
sapply(results, function(feature) {
model = gam(.value~.borders, data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = ((y2-y1)/(feature$.borders+epsilon - feature$.borders))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
}
return(res)
}
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.01))
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.1))
model = gam(.value~.borders, data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = ((y2-y1)/(feature$.borders+epsilon - feature$.borders))
y1
y2
model
AME_ALE = function(data, predict_f, model, epsilon = NULL) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
if(is.null(epsilon)){
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
} else {
res=
sapply(results, function(feature) {
model = gam(.value~s(.borders), data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = ((y2-y1)/(feature$.borders+epsilon - feature$.borders))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
}
return(res)
}
(res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.1))
t((res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.1)))
t((res_AME_ALE = AME_ALE(dat2, predict_xg, brt)))
mm = (lm(y~. + I(x1^2), data = as.data.frame(dat)))
margins::margins(mm)
mm = (lm(y~I(x1^2)+x2+x3+x4, data = as.data.frame(dat)))
margins::margins(mm)
n = 1000
c = 0.97
AB = mvtnorm::rmvnorm(n, sigma = matrix(c(1, c, c, 1), 2, 2))
x1 = AB[,1]
x2 = AB[,2]
x3 = rnorm(n)
x4 = rnorm(n)
x5 = rnorm(n)
x6 = rnorm(n)
y = x1**2 + x2 + 0*x3 + rnorm(n)
dat = data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5, x6 = x6)
#nn = data.frame(matrix(runif(n*20), n, 20))
#colnames(nn) = paste0("A", 1:20)
#dat = cbind(dat, nn)
cor(dat$x1, dat$x2)
dat2 = as.matrix(dat)
dat2 = scale(dat2)
brt = xgboost::xgboost(data=xgboost::xgb.DMatrix(dat2[,-1], label = (dat2[,1, drop=FALSE])),
nrounds = 200L, objective="reg:linear",params = list(nthread = 3))
AME_direct = function(data, predict_f, model, epsilon = 0.1) {
data = data[,-1]
res=
sapply(1:ncol(data), function(p) {
eps = epsilon*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(t(res))
}
res_AME_direct = AME_direct(dat2, predict_xg, brt)
res_AME_direct
head(dat2)
AME_direct = function(data, predict_f, model, epsilon = 0.1) {
data = data[,-1]
res=
sapply(1:ncol(data), function(p) {
eps = epsilon*sd(data[,p])
grads = sapply(1:nrow(data), function(i) {
tmp1 = data[i,,drop=FALSE]
y1 = predict_f(model, newdata = tmp1)
tmp2 = tmp1
tmp2[1,p] = tmp1[1,p] + eps
y2 = predict_f(model, newdata = tmp2)
return((y2-y1)/(tmp2[1,p]-tmp1[1,p]))
})
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
return(t(res))
}
((res_AME_ALE = AME_ALE(dat2, predict_xg, brt)))
((res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.1)))
res_AME_direct
AME_ALE = function(data, predict_f, model, epsilon = NULL) {
predictor <- Predictor$new(model, data = data.frame(data[,-1]), y = data[,1], predict.function = predict_f)
ALE <- FeatureEffects$new(predictor, method = "ale")
results = ALE$results
if(is.null(epsilon)){
res=
sapply(results, function(feature) {
len = nrow(feature)
grads = ((feature$.value[2:len]-feature$.value[1:(len-1)])/(feature$.borders[2:len] - feature$.borders[1:(len-1)]))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
} else {
res=
sapply(results, function(feature) {
model = gam(.value~s(.borders), data = feature)
y1 = predict(model, newdata= data.frame(.borders= feature$.borders))
y2 = predict(model, newdata= data.frame(.borders= feature$.borders+epsilon))
grads = ((y2-y1)/(feature$.borders+epsilon - feature$.borders))
return(c(mean(grads), mean(abs(grads)), sd(grads)))
})
}
return(t(res))
}
((res_AME_ALE = AME_ALE(dat2, predict_xg, brt)))
((res_AME_ALE = AME_ALE(dat2, predict_xg, brt, epsilon = 0.1)))
mm = (lm(y~I(x1^2)+x2+x3+x4+x5+x6, data = as.data.frame(dat)))
margins::margins(mm)
dat = scale(dat)
mm = (lm(y~I(x1^2)+x2+x3+x4+x5+x6, data = as.data.frame(dat)))
margins::margins(mm)
res_AME_direct
rr = (get_importance2(brt, predict_xg, dat))
rr = (get_importance2(brt, predict_xg, dat2))
plot(rr[[1]])
rr[[2]]
gg = (gam(y~x1+x2+x3+x4+x5+x6, data = as.data.frame(dat)))
margins(gg)
install.packages("bookdown")
